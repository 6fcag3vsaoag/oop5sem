# Лабораторная работа №7. C++ Шаблоны

## Цель работы
Получение навыков в разработке программ с использованием шаблонов классов.

## Задание
Создать шаблон класса «стек». Написать программу, моделирующую процесс прибытия и отъезда машин с использованием этого шаблона класса.

Гаражная стоянка имеет одну стояночную полосу, причем въезд и выезд находятся в одном конце полосы. Если владелец автомашины приходит забрать свой автомобиль, который не является ближайшим к выходу, то все автомашины, загораживающие проезд, удаляются, машина данного владельца выводится со стоянки, а другие машины возвращаются на стоянку в исходном порядке.

Прибытие или отъезд автомашины задается командной строкой, которая содержит признак прибытия или отъезда и номер машины. Программа должна выводить сообщение при прибытии или выезде любой машины. При выезде автомашины со стоянки сообщение должно содержать число раз, которое машина удалялась со стоянки для обеспечения выезда других автомобилей.

## Структура проекта
- `Stack.h` - Шаблон класса стека
- `Car.h` / `Car.cpp` - Класс автомобиля
- `Parking.h` / `Parking.cpp` - Класс гаражной стоянки
- `main.cpp` - Основной файл программы
- `Makefile` - Файл для сборки проекта

## Компиляция и запуск

### С использованием Makefile
```bash
# Компиляция
make

# Запуск
make run

# Очистка
make clean
```

### Ручная компиляция
```bash
g++ -std=c++11 -Wall -Wextra -o parking_simulation main.cpp Car.cpp Parking.cpp
./parking_simulation
```

## Использование программы
После запуска программы вы можете использовать следующие команды:
- `a <номер>` - Прибытие автомобиля с указанным номером
- `d <номер>` - Отъезд автомобиля с указанным номером
- `q` - Выход из программы

Пример:
```
> a 123
Car #123 has arrived and parked.
Parking status (1 cars):

> a 456
Car #456 has arrived and parked.
Parking status (2 cars):

> d 123
Car #123 has departed. It was removed 0 times for other cars to exit.
Parking status (1 cars):
```

## Контрольные вопросы

1. **Что такое шаблон?**
   Шаблон в C++ - это конструкция, которая позволяет создавать обобщенные функции и классы, работающие с различными типами данных без дублирования кода. Шаблоны позволяют писать параметризованный код, где типы данных становятся параметрами.

2. **Для чего может быть определен шаблон?**
   Шаблоны определяются для:
   - Создания обобщенных алгоритмов, работающих с разными типами данных
   - Реализации контейнерных классов (например, векторов, списков, стеков)
   - Повышения переиспользуемости кода
   - Уменьшения дублирования кода при работе с разными типами данных

3. **Расскажите о назначении шаблонов.**
   Шаблоны предназначены для:
   - Обобщенного программирования - написания кода, который может работать с различными типами данных
   - Типобезопасности - проверка типов происходит на этапе компиляции
   - Эффективности - отсутствие накладных расходов во время выполнения по сравнению с использованием void* или наследования
   - Поддержки принципа DRY (Don't Repeat Yourself) - избегания дублирования кода

4. **Приведите синтаксис объявления шаблона класса.**
   ```cpp
   template &lt;typename T&gt;
   class ClassName {
       // Члены класса
   };
   
   // Или с несколькими параметрами:
   template &lt;typename T, typename U&gt;
   class ClassName {
       // Члены класса
   };
   ```

5. **Может ли быть список параметров шаблона пустым?**
   Нет, список параметров шаблона не может быть пустым. Если шаблон определен, то он должен иметь хотя бы один параметр. Однако можно использовать параметры по умолчанию:
   ```cpp
   template &lt;typename T = int&gt;
   class ClassName {
       // ...
   };
   ```

6. **Есть ли ошибка в определении шаблона: `template&lt;class T, class U&gt;void foo (T*, U)?`**
   Да, есть синтаксическая ошибка. Правильное определение должно быть:
   ```cpp
   template&lt;class T, class U&gt; void foo(T*, U) {
       // Реализация
   }
   ```
   Не хватает фигурных скобок и пробела между закрывающей скобкой шаблона и именем функции.

7. **Может ли быть непараметризовано возвращаемое шаблоном функции значение? Приведите пример.**
   Да, возвращаемое значение может быть непараметризованным:
   ```cpp
   template &lt;typename T&gt;
   int getSize(const T&amp; container) {
       return container.size();
   }
   ```
   В этом примере функция всегда возвращает int, независимо от типа параметра T.

8. **Можно ли перегружать шаблоны функции?**
   Да, шаблоны функций можно перегружать. Можно иметь несколько шаблонов с разным количеством или типами параметров, а также комбинировать шаблонные и нешаблонные функции:
   ```cpp
   template &lt;typename T&gt;
   void print(const T&amp; value) {
       std::cout &lt;&lt; "Template: " &lt;&lt; value &lt;&lt; std::endl;
   }
   
   template &lt;typename T, typename U&gt;
   void print(const T&amp; value1, const U&amp; value2) {
       std::cout &lt;&lt; "Two params: " &lt;&lt; value1 &lt;&lt; ", " &lt;&lt; value2 &lt;&lt; std::endl;
   }
   
   void print(int value) {
       std::cout &lt;&lt; "Specialized for int: " &lt;&lt; value &lt;&lt; std::endl;
   }
   ```