# Лабораторная работа №8. Практические приемы использования шаблонов классов. Реализация smart-указателей

## Цель работы
Получение навыков моделирования и реализации иерархии классов, а также использования статических данных и методов класса.

## Задание
Использовать классы, разработанные в лабораторной работе № 2.
1. Создать несколько объектов класса с использованием smart-указателей класса unique_ptr. Применить к объектам методы класса. Уничтожить объекты путем уничтожения указателей.
2. Создать несколько объектов класса с использованием smart-указателей класса shared_ptr. Причем на один объект должно указывать несколько указателей. Число существующих указателей отслеживается при помощи счетчика ссылок. Уничтожить объекты.
3. Создать несколько объектов класса с использованием smart-указателей класса weak_ptr. Применить к объектам методы класса. Уничтожить объекты путем уничтожения указателей.

## Структура проекта
- `Stack.h` - Шаблон класса стека
- `Car.h` / `Car.cpp` - Класс автомобиля
- `Parking.h` / `Parking.cpp` - Класс гаражной стоянки
- `main.cpp` - Основной файл программы
- `Makefile` - Файл для сборки проекта
- `README.md` - Этот файл

## Контрольные вопросы

1. **В каких случаях следует использовать shared_ptr, а в каких - unique_ptr?**
   - `unique_ptr` следует использовать, когда объект должен иметь одного владельца. Он обеспечивает уникальное владение объектом и автоматически удаляет объект при выходе из области видимости. `unique_ptr` эффективен по памяти и производительности.
   - `shared_ptr` следует использовать, когда объект может иметь несколько владельцев. Он отслеживает количество ссылок на объект и удаляет его, когда счетчик ссылок достигает нуля. Используется, когда невозможно определить время жизни объекта заранее.

2. **Почему практически всегда следует использовать make_shared для создания объекта, которым будут впоследствии владеть shared_ptr?**
   - `make_shared` более эффективен, потому что выделяет память для объекта и для управляющего блока `shared_ptr` в одном блоке памяти, что уменьшает количество выделений памяти.
   - `make_shared` безопаснее, потому что гарантирует, что объект и управляющий блок создаются атомарно.
   - `make_shared` также уменьшает размер кода и может быть немного быстрее при создании объекта.

3. **Почему практически всегда следует использовать make_unique для создания объекта, которым будет владеть unique_ptr? Объясните.**
   - `make_unique` предотвращает утечки памяти при возникновении исключений. Если напрямую использовать `new` и передавать результат в конструктор `unique_ptr`, может произойти утечка памяти, если вызов конструктора выбросит исключение.
   - `make_unique` более безопасен и проще в использовании, так как автоматически выводит тип создаваемого объекта.
   - `make_unique` также делает код более читаемым и соответствует современным практикам C++.

4. **Что такое auto_ptr?**
   - `auto_ptr` - это устаревший класс умных указателей из стандартной библиотеки C++98/03, который был удален в C++17.
   - Он пытался реализовать семантику уникального владения, но имел проблемы с безопасностью: при копировании объекта происходило передача владения, что могло приводить к неопределенному поведению.
   - Его заменили на `unique_ptr`, который реализует семантику перемещения вместо семантики копирования, что намного безопаснее.

5. **Что такое циклическая ссылка?**
   - Циклическая ссылка возникает, когда два или более объекта содержат `shared_ptr` друг на друга, создавая цикл.
   - Это приводит к утечке памяти, потому что счетчики ссылок никогда не достигают нуля, и объекты никогда не удаляются.
   - Для решения этой проблемы используются `weak_ptr`, которые не увеличивают счетчик ссылок, но позволяют получить доступ к объекту при необходимости.